## 生命周期
- 创建前/后： 在beforeCreated阶段，vue实例的挂载元素
$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。
- 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。
- 更新前/后：当data变化时，会触发beforeUpdate和updated方法。
- 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在
- activated和deactivated 分别在keep-alive激活和关闭时调用
- errorCaptured当捕获一个来自子孙组件的错误时被调用。
## eventbus
1. 创建eventbus.js文件
```
import Vue from 'vue'
export const EventBus = new Vue()
```
2. 父组件子组件都引入
```
import { EventBus } from "./event-bus.js";//父组件
EventBus.$on("事件", {})

import { EventBus } from "./event-bus.js"; //子组件
EventBus.$emit("事件", {})
```
## 响应式
## computed和methods watch的区别
## 组件通信方式
## vuex
## 路由的实现
vue-router中，它提供mode参数来决定采用哪一种方式
##### Hash
- hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面
- 每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录
##### History
- HTML5，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改：
##### 比较
- hash丑
- pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL

- pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中

- pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串

- pushState可额外设置title属性供后续使用

## 路由传参
##### 编程式的导航的传参 router.push
命名路由传参 __不会在url出现__
```
this.$router.push({ name: 'news', params: { userId: 123 }})
```
接收方
```
this.$route.params.userId
```
查询参数传参 __会在url出现__
查询参数就是在路由地址后面带上参数和传统的url参数一致的，传递参数使用query而且必须配合path来传递参数而不能用name，目标页面接收传递的参数使用query。
```
this.$router.push({ path: '/news', query: { userId: 123 }});
```
接收方
```
this.$route.query.userId
```
==name配对的是params，和path配对的是query==
##### 声明式的导航的传参 router-link
命名路由  __不会在url出现__
```
<router-link :to="{ name: 'news', params: { userId: 1111}}">click to news page</router-link>
```
查询参数 __会在url出现__
```
<router-link :to="{ path: '/news', query: { userId: 1111}}">click to news page</router-link>
```
1. 命名路由搭配params，刷新页面参数会 __丢失__
2. 查询参数搭配query，刷新页面数据 __不会丢失__
3. 接受参数使用this.$router后面就是搭配路由的名称就能获取到参数的值
## 动态路由
```
routes: [
    // 动态路径参数 以冒号开头
    { path: '/user/:id', component: User }
  ]
```
- 当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，也意味着组件的生命周期钩子不会再被调用。可以用==watch==或者==beforeRouteUpdate==来监听路由变化
## api
- __router.push__ 这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。
- __router.replace__ 不会向 history 添加新记录
- __router.go(n)__ 在 history 记录中向前或者后退多少步
- __重定向redirect__
```
routes: [
    { path: '/a', redirect: '/b' }
  ]
```
## 性能优化